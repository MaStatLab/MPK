{
    "contents" : "#include <RcppArmadillo.h>\n#include <omp.h>\n#include \"helpers.h\"\n#include \"gibbs.h\"\n\nusing namespace Rcpp;\nusing namespace arma;\nusing namespace std;\n\n\nMCMC::MCMC( mat Y, \n            vec C, \n            Rcpp::List prior,\n            Rcpp::List mcmc,\n            Rcpp::List state ) :\n            Y(Y), \n            C(C)\n{\n       \n      p = Y.n_cols;  \n      n = Y.n_rows;\n\n      // Number of data sets\n      J = C.max() + 1;\n\n      K = Rcpp::as<int>(prior[\"K\"]);\n      num_iter = Rcpp::as<int>(mcmc[\"nskip\"]) * Rcpp::as<int>(mcmc[\"nsave\"]);\n      num_burnin = Rcpp::as<int>(mcmc[\"nburn\"]);\n      num_thin = Rcpp::as<int>(mcmc[\"nskip\"]);    \n      num_display = Rcpp::as<int>(mcmc[\"ndisplay\"]);    \n\n      // set Armadillo seed (Rcpp seed inherited from R in mpg.R)\n      // NOTE: Rstudio seems to touch Armadillo's underlying RNG, so\n      // differing results may be seen when run from Rstudio, see comments\n      // from Dirk Eddelbuettel here:\n      //  https://github.com/RcppCore/RcppArmadillo/issues/11\n      seed = Rcpp::as<int>(mcmc[\"seed\"]);\n      arma::arma_rng::set_seed(seed);\n\n      m_2 = Rcpp::as<vec>(prior[\"m_2\"]);\n      nu_2 = Rcpp::as<double>(prior[\"nu_2\"]);    \n      nu_1 = Rcpp::as<double>(prior[\"nu_1\"]);    \n      Psi_2 = Rcpp::as<mat>(prior[\"Psi_2\"]);\n      inv_S_2 = inv(Rcpp::as<mat>(prior[\"S_2\"]));\n      tau_k0 = Rcpp::as<vec>(prior[\"tau_k0\"]);\n      tau_alpha = Rcpp::as<vec>(prior[\"tau_alpha\"]);\n      tau_epsilon = Rcpp::as<double>(prior[\"tau_epsilon\"]);\n      tau_epsilon0 = Rcpp::as<vec>(prior[\"tau_epsilon0\"]);\n      merge_step = Rcpp::as<bool>(prior[\"merge_step\"]);\n      merge_par = Rcpp::as<double>(prior[\"merge_par\"]);\n      Z_input = Rcpp::as<uvec>(state[\"Z\"]);\n      \n      length_chain =  num_iter/num_thin;\n      saveAlpha.set_size(length_chain);\n      saveW.set_size(J,K,length_chain);\n      saveK0.set_size(length_chain);\n      saveEpsilon0.set_size(length_chain);\n      saveEpsilon.set_size(length_chain,K);\n      saveZ.set_size(length_chain,n);\n      saveMu.set_size(J,K*p,length_chain);\n      saveMu0.set_size(p,K,length_chain);\n      saveOmega.set_size(p,K*p,length_chain);   \n      saveOmega1.set_size(p,p,length_chain);  \n      saveM1.set_size(length_chain,p);   \n      saveOdds.set_size(length_chain,n);\n      \n      main_loop(state);\n                                  \n}\n\nvoid MCMC::main_loop(Rcpp::List state)\n{    \n  \n  /* --- support variables --- */\n  \n  // counter\n  int km = 0;\n   // number of observations per group and per component\n  mat N(J,K);\n  // used in the swap step\n  mat temp;\n  vec indices;\n  // latent assignments\n  uvec Z = Z_input;\n\n  /* --- parameters --- */\n  \n  // link between mean and covariance\n  double k_0 = Rcpp::as<double>(state[\"k_0\"]);\n  // perturbation parameter for the mean\n  double epsilon0  = Rcpp::as<double>(state[\"epsilon_0\"]);\n  double epsilon0_old = epsilon0;\n  double epsilon0_par = sqrt(K);\n  vec epsilon = Rcpp::as<vec>(state[\"epsilon\"]);\n  int epsilon0_count = 0; \n  int epsilon0_tot = 100;\n  // mass parameter for the dirichlet prior on the mixture weights\n  double alpha = Rcpp::as<double>(state[\"alpha\"]);\n  double alpha_old = alpha;\n  double alpha_par = sqrt(K);\n  double alpha_count = 0; \n  int alpha_tot = 100; \n  // mixture weights\n  mat logW = log( Rcpp::as<mat>(state[\"w\"]) );   // J x K matrix\n  // mean \\mu_{j,k}\n  mat mus = Rcpp::as<mat>(state[\"mus\"]);\n  cube mu(J,p, K);\n  for(int k = 0; k < K; k++)\n    mu.slice(k) = mus.cols( p*k , p*(k+1)-1);\n  // centering of mean locations \\mu_k\n  mat mu_0 = Rcpp::as<mat>(state[\"mu_0\"]);     // p x K matrix\n  // covariance locations\n  cube Sigma(p,p,K);\n  // precision locations\n  mat Omegas = Rcpp::as<mat>(state[\"Omegas\"]); \n  cube Omega(p,p,K);\n  for(int k = 0; k < K; k++)\n  {\n    Omega.slice(k) = Omegas.cols(p*k, p*(k+1)-1);\n    Sigma.slice(k) = inv_sympd(Omega.slice(k));\n  }\n    \n  // centering for the Wishart prior \n  mat Omega_1 = Rcpp::as<mat>(state[\"Omega_1\"]); \n  mat Sigma_1 = inv_sympd(Omega_1);  \n  // mean of the mean\n  vec m_1 = Rcpp::as<vec>(state[\"m_1\"]); \n    \n\n  kernel_coeffs_type kc;  \n  \n  /*\n  for(int k = 0; k < K; k++ )\n  {\n    kc = InitMuSigma(Z, epsilon0, k); \n    mu.slice(k) = kc.mu; \n    mu_0.col(k) = kc.mu_0;\n    Omega.slice(k) = kc.Omega;   \n    Sigma.slice(k) = kc.Sigma;   \n    epsilon(k) = kc.epsilon;\n  }\n  */  \n  // assign each observation to a mixture component\n  \n  List tempZ = UpdateZetas(mu, Omega, logW);   \n  Z = Rcpp::as<uvec>(tempZ[\"Z\"]);  \n  N = Rcpp::as<mat>(tempZ[\"N\"]);\n  \n  int max_threads = omp_get_max_threads();\n  cout << \"Maximum threads available: \" << max_threads << endl;\n      \n  /* --- let the chain run --- */\n\n  for(int it=0; it<(num_iter + num_burnin); it++)\n  {          \n    if((it+1)%num_display==0)\n      cout << \"Iteration: \" << it + 1 << \" of \" << num_iter + num_burnin << endl;\n            \n    // MERGE STEP\n    if(merge_step)\n    {\n      for( int k=0; k< K - 1 ; k++ )\n      {\n        if( sum(N.col(k)) > 0 )\n        {\n          for(int kk=k+1; kk < K ; kk++)\n          {\n            if( sum(N.col(kk)) > 0  )\n            {\n              \n              double kl_div = KL( mu_0.col(k), \n                                  mu_0.col(kk), \n                                  Sigma.slice(k), \n                                  Omega.slice(k), \n                                  Sigma.slice(kk), \n                                  Omega.slice(kk) ) / epsilon0 ;\n              if( kl_div < R::qchisq(merge_par, (double)p, 1, 0) )\n              {\n                \n                mu_0.col(k) = mu_0.col(k)*sum(N.col(k)) + mu_0.col(kk)*sum(N.col(kk));\n                for(int j = 0; j<J; j++)\n                  mu.slice(k).row(j) =  mu.slice(k).row(j)*( (N(j,k)+0.5 )/(N(j,k)+N(j,kk)+1.0) ) + mu.slice(k).row(j)*( (N(j,kk)+0.5 )/(N(j,k)+N(j,kk)+1.0) );\n                Sigma.slice(k) = Sigma.slice(k)*sum(N.col(k)) + Sigma.slice(kk)*sum(N.col(kk));\n                Omega.slice(k) = inv_sympd(Sigma.slice(k));\n                epsilon(k) = epsilon(k)*sum(N.col(k)) + epsilon(kk)*sum(N.col(kk));\n                N.col(k) = N.col(k) + N.col(kk);\n                N.col(kk) = zeros<vec>(J);                  \n                kc = PriorMuSigmaEpsilon(  Sigma_1, \n                                           Omega_1, \n                                           k_0, \n                                           epsilon0,\n                                           m_1 );\n                mu.slice(kk) = kc.mu;\n                mu_0.col(kk) = kc.mu_0;\n                Omega.slice(kk) = kc.Omega;   \n                Sigma.slice(kk) = kc.Sigma;       \n                epsilon(kk) = kc.epsilon;\n                        \n              }\n  \n            }\n  \n          }\n        }\n  \n      }\n    }\n    \n                \n    alpha_old = alpha;  \n    alpha = UpdateAlpha( alpha, N, alpha_par );\n    if( it <= num_burnin )\n    {\n      if( alpha != alpha_old )\n        alpha_count++;\n           \n      if( (it+1)  % alpha_tot == 0)\n      {\n        if( alpha_count < 30 )\n          alpha_par *= 1.1;\n        if( alpha_count > 50 )  \n          alpha_par *= 0.9;\n        alpha_count = 0;        \n      }      \n    }  \n    else\n    {\n        if( alpha != alpha_old )\n          alpha_count++;\n    }        \n    \n    logW = UpdateLogWs( N, alpha );\n    \n    List tempZ = UpdateZetas(mu, Omega, logW);   \n    Z = Rcpp::as<uvec>(tempZ[\"Z\"]);  \n    N = Rcpp::as<mat>(tempZ[\"N\"]);  \n    \n    mat norm_draws = randn<mat>( K*(J+1), p);\n    mat norm_draws_cov = randn<mat>( nu_1*K + n, p);\n    vec dfs = zeros<vec>( K + 1 );\n    dfs.rows(1, K)  =  cumsum( sum(N, 0).t() + nu_1 );\n    \n    // #pragma omp parallel for private(tempSMuSigma)\n    for(int k=0; k < K; k++)\n    {      \n      kc = UpdateMuSigmaEpsilon(  Z,\n                                  k,\n                                  mu_0.col(k),\n                                  Sigma_1, \n                                  Omega_1,\n                                  k_0, \n                                  epsilon(k),\n                                  epsilon0,\n                                  m_1,\n                                  norm_draws.rows( (J+1)*k, (J+1)*(k+1) - 1 ),\n                                  norm_draws_cov.rows(dfs(k), dfs(k+1) - 1 )\n                                ); \n      mu.slice(k) = kc.mu; \n      mu_0.col(k) = kc.mu_0;\n      Omega.slice(k) = kc.Omega;   \n      Sigma.slice(k) = kc.Sigma;  \n      epsilon(k) = kc.epsilon;\n\n    }  \n    \n    k_0 =  UpdateK0(Omega, mu_0, m_1);\n    \n    Sigma_1 = UpdateSigma1(Omega);\n    Omega_1 = inv_sympd(Sigma_1);\n    \n    m_1 = UpdateM1( k_0, mu_0, Omega );\n    \n    \n    epsilon0_old = epsilon0;\n    epsilon0 = UpdateEpsilon0(  epsilon0_old, \n                                epsilon, \n                                tau_epsilon, \n                                tau_epsilon0,\n                                epsilon0_par  );     \n    \n    if( it <= num_burnin )\n    {\n      if( epsilon0 != epsilon0_old )\n        epsilon0_count++;\n        \n      if( (it+1)  % epsilon0_tot == 0)\n      {\n        if( epsilon0_count < 30 )\n          epsilon0_par *= 1.1;\n        if( epsilon0_count > 50 )  \n          epsilon0_par *= 0.9;\n        epsilon0_count = 0;\n      }      \n    }  \n    else\n    {\n      if( epsilon0 != epsilon0_old )\n        epsilon0_count++;\n    }\n    \n  \n    \n    if( (it+1 > num_burnin) && ((it+1) % num_thin == 0))\n    {  \n      // save chain\n      saveK0(km) = k_0;\n      saveEpsilon0(km) = epsilon0;\n      saveEpsilon.row(km) = epsilon.t();\n      saveM1.row(km) = m_1.t();\n      saveAlpha(km) = alpha;\n      saveW.slice(km) = exp(logW);   \n      saveOmega.slice(km) = reshape( mat(Omega.memptr(), Omega.n_elem, 1, false), p, K*p); \n      saveOmega1.slice(km) = Omega_1;\n      saveMu.slice(km) = reshape( mat(mu.memptr(), mu.n_elem, 1, false), J, K*p);   \n      saveMu0.slice(km) = mu_0;\n      saveZ.row(km) = Z.t();  \n      \n      mat W = exp(logW);\n      for(int i = 0; i < n; i++)\n        saveOdds(km, i) = log(W(C(i),Z(i)) + DBL_MIN) \n          - log(1 + DBL_MIN - W(C(i),Z(i)) )\n          - log( (sum( W.col(Z(i)) ) - W(C(i),Z(i)))/(J-1) + DBL_MIN  )\n          + log( 1 + DBL_MIN - (sum( W.col(Z(i)) ) - W(C(i),Z(i)))/(J-1) );\n      \n      km++;        \n    }\n      \n      \n  }\n  \n  cout << endl << \"MH acceptance rate \" << endl;\n  cout << \"epsilon0: \" << (double)epsilon0_count/num_iter << endl;\n  cout << \"alpha: \" << alpha_count / (double)num_iter << endl;\n  \n}     \n\n\n\n\nkernel_coeffs_type MCMC::InitMuSigma(uvec Z, double epsilon0, int k)\n{\n  kernel_coeffs_type output;\n  mat EmpCov = eye<mat>(p,p) + cov(Y);\n  mat tempInit = mvrnormArma(J, zeros<vec>(p) , eye<mat>(p,p));\n  mat mu_k(J,p);\n  vec mu_0k(p);  \n  mat Sigma_k(p,p);\n  mat Omega_k(p,p);\n  double epsilon = 1 / rgammaBayes( tau_epsilon, tau_epsilon*epsilon0);\n  \n  uvec Zk = arma::find(Z==k);\n  if( Zk.n_elem > 0 )\n  {\n    mu_0k = mean(Y.rows(Zk),0).t(); \n    \n    if( Zk.n_elem > (uint)p + 2 )\n      Sigma_k = cov(Y.rows(Zk));  \n    else\n      Sigma_k = EmpCov;  \n      \n    Omega_k = inv(Sigma_k);\n    for(int j=0; j<J; j++)  \n        mu_k.row(j) = mean(Y.rows(Zk),0) + 0.1*tempInit.row(j);           \n  }\n  else\n  {\n    mu_0k = tempInit.row(1).t();\n    Sigma_k = EmpCov;  \n    Omega_k = inv(Sigma_k);\n    for(int j=0; j<J; j++)  \n      mu_k.row(j) = mu_0k.t() + 0.1*tempInit.row(j);        \n    \n  }           \n  output.mu_0 = mu_0k;\n  output.mu = mu_k;\n  output.Sigma = Sigma_k;\n  output.Omega = Omega_k;\n  output.epsilon = epsilon;  \n  return output ;   \n  \n}\n\n\nRcpp::List MCMC::GenerateZetas( arma::mat log_like,\n                                arma::mat logW  )\n{\n  // J is the number of data sets,\n  // K is the number of mixture components\n  // So, N has a row for each data set, a column for each component\n  mat N(J, K);\n  N.fill(0);\n\n  // Zeta vector assigning each data point to a component\n  uvec Z(n);\n  Z.fill(0);\n\n  // generate a new random uniform distribution for this iteration\n  NumericVector U = runif(n);\n\n  // log likelihood\n  double tot_log_like = 0.0;\n  vec prob;\n  vec probsum;\n  double x;\n  bool not_assigned;\n\n  int i;\n  int k;\n  #pragma omp parallel for private(k, prob, probsum, x, not_assigned)\n  for(i = 0; i < n; i++)\n  {\n    prob = exp(log_like.row(i).t() + logW.row(C(i)).t());\n    probsum = cumsum(prob);\n    x = U(i) * sum(prob);\n    not_assigned = true;\n    for (k = 0; (k < K) && not_assigned; k++)\n    {\n      if(x <= probsum(k))\n      {\n        Z(i) = k;\n        not_assigned = false;\n      }\n    }\n  }\n\n  for(i = 0; i < n; i++) {\n    N(C(i), Z(i))++;\n    tot_log_like += log_like(i,Z(i));\n  }\n\n  return Rcpp::List::create(  Rcpp::Named( \"Z\" ) = Z,\n                              Rcpp::Named( \"N\" ) = N,\n                              Rcpp::Named( \"tot_log_like\" ) = tot_log_like ) ;\n}\n\n\nRcpp::List MCMC::UpdateZetas(   arma::cube mu,\n                                arma::cube Omega,\n                                arma::mat logW )\n{\n  mat log_like(n, K);\n  uvec C_j;\n  int j;  // used as private index of for loop inside omp below\n  \n  #pragma omp parallel for private(j, C_j)\n  for(int k = 0; k < K; k++)\n  {\n    uvec index(1);\n    index(0) = k;\n    for(j=0; j < J; j++)\n    {\n      C_j = arma::find(C==j);\n      log_like.submat(C_j,  index) = dmvnrm_arma_precision(\n        Y.rows(C_j),\n        mu.slice(k).row(j),\n        Omega.slice(k)  );\n    }\n  }  \n  \n  Rcpp::List zetas_output = GenerateZetas(log_like, logW);\n  \n  return zetas_output;\n}\n\n\ndouble MCMC::UpdateAlpha(double alpha, arma::mat N, double alpha_par)\n{\n  double output = alpha;    \n  double log_ratio = 0;\n  double temp = rgammaBayes(  pow( alpha, 2 ) * alpha_par, \n                        alpha * alpha_par );\n  \n  log_ratio += R::dgamma(alpha, pow(temp,2)* alpha_par, 1/temp/alpha_par, 1);                          \n  log_ratio -= R::dgamma(temp, pow(alpha,2)* alpha_par, 1/alpha/alpha_par, 1);  \n  log_ratio += R::dgamma(temp, tau_alpha(0), 1/tau_alpha(1), 1);\n  log_ratio -= R::dgamma(alpha, tau_alpha(0), 1/tau_alpha(1), 1);\n  \n  for(int j = 0; j < J; j++)\n  {\n      log_ratio += marginalLikeDirichlet( N.row(j).t(), (temp/K)*ones<vec>(K)  );\n      log_ratio -= marginalLikeDirichlet( N.row(j).t(), (alpha/K)*ones<vec>(K)  );\n  }\n  if( exp(log_ratio) > R::runif(0,1) )\n      output = temp;\n      \n  return output;\n}\n\n\n\n\narma::mat MCMC::UpdateLogWs(   arma::mat N, \n                               double alpha  )\n{\n  \n  mat logW(J,K);  \n\n  for(int j=0; j<J; j++)\n    logW.row(j) = rDirichlet( N.row(j).t() +  alpha * ones<vec>(K) / K  ).t();\n  \n  return logW ;      \n}\n\n\n\n\n\nkernel_coeffs_type MCMC::UpdateMuSigmaEpsilon(    arma::uvec Z,\n                                                  int k, \n                                                  arma::vec mu_0,\n                                                  arma::mat Sigma_1, \n                                                  arma::mat Omega_1, \n                                                  double k_0, \n                                                  double epsilon,\n                                                  double epsilon0,\n                                                  arma::vec m_1,\n                                                  arma::mat mean_std,\n                                                  arma::mat cov_std  ) \n{ \n  kernel_coeffs_type output;\n  uvec Z_k = arma::find(Z==k);  \n  mat data_group = Y.rows(Z_k);\n  vec C_k = C(Z_k);\n  int p = data_group.n_cols;\n  int N_k = data_group.n_rows;   \n  mat Omega(p,p);\n  mat Sigma(p,p);\n  mat mu(p,J);\n  mat mu_0new(p,1);  \n  double epsilon_new;\n  \n  if(N_k == 0)\n  {\n    Omega = WishartScaling(cov_std, Omega_1);\n    Sigma = inv_sympd( Omega );       \n    mu_0new = trans( mvrnormScaling(mean_std.row(0).cols(0,p-1), m_1, Sigma/k_0) );    \n    \n    for(int j=0; j<J; j++)\n      mu.col(j) = trans( mvrnormScaling(mean_std.row(j+1).cols(0,p-1), mu_0new,  Sigma*epsilon ));      \n      \n    epsilon_new = 1 / rgammaBayes(tau_epsilon, tau_epsilon*epsilon0);  \n    \n  }\n  else  // N_k > 0\n  {\n        \n    mat  Psi_1(p,p);\n    double extra_piece_var_1 = 0;\n    vec  m1_1(p);\n    \n    vec n_jk(J);\n    mat mean_jk(p,J); mean_jk.fill(0);\n    vec mean_k = mean(data_group,0).t();\n    mat SS_jk(p,p), ss_jk_1(p,p);\n    \n    // marginal likelihood under model 0\n    mat mean_k_rep = repmat( mean_k.t(), N_k, 1);\n    mat SS_k = ( data_group - mean_k_rep ).t() * ( data_group - mean_k_rep );\n    mat ss_k = N_k * ( mean_k - mu_0 ) * ( mean_k - mu_0 ).t();        \n    \n    // marginal likelihood under model 1 \n    extra_piece_var_1 = k_0;\n    m1_1 = k_0 * m_1;     \n    SS_jk.fill(0);\n    ss_jk_1.fill(0);\n\n    for(int j=0; j<J; j++)\n    {\n      uvec indices = find(C_k==j);\n      n_jk(j) = indices.n_elem;     \n      \n      if (n_jk(j) > 0)\n      {\n          mean_jk.col(j) = mean(data_group.rows(indices),0).t();\n          mat mean_jk_rep = repmat( trans(mean_jk.col(j)),(int)n_jk(j), 1);\n          SS_jk = SS_jk + (data_group.rows(indices) - mean_jk_rep).t() * ( data_group.rows(indices) - mean_jk_rep );\n          ss_jk_1 = ss_jk_1 + (mean_jk.col(j) - mu_0) * (mean_jk.col(j) - mu_0).t() / (epsilon + 1.0/n_jk(j));\n          extra_piece_var_1 +=  n_jk(j) / (epsilon * n_jk(j) + 1.0);\n          m1_1 = m1_1 +  n_jk(j) / (epsilon * n_jk(j) + 1.0) * mean_jk.col(j);\n         \n      }\n    }          \n    Psi_1 = inv_sympd( Sigma_1 + SS_jk + ss_jk_1 );     \n\n    Omega = WishartScaling(cov_std, Psi_1);\n    Sigma = inv_sympd( Omega ); \n    m1_1 = m1_1 / extra_piece_var_1;\n    mu_0new = trans( mvrnormScaling(mean_std.row(0).cols(0,p-1), m1_1, Sigma/extra_piece_var_1));\n    \n    double temp_ss = 0;\n    for(int j=0; j<J; j++)\n    {\n      if( n_jk(j) > 0 )\n      {\n        mu.col(j) = trans( mvrnormScaling(mean_std.row(j+1).cols(0,p-1), \n          (n_jk(j)*mean_jk.col(j) + 1.0/epsilon*mu_0new)/(n_jk(j) + 1.0/epsilon), \n          Sigma/(n_jk(j) + 1.0/epsilon)));\n      }\n      else\n        mu.col(j) = trans( mvrnormScaling(mean_std.row(j+1).cols(0,p-1), mu_0new,  Sigma*epsilon) );           \n        \n      temp_ss +=  as_scalar( ( mu.col(j).t() - mu_0new.t()) * Omega * ( mu.col(j) - mu_0new ) ); \n    }  \n    \n    epsilon_new = 1 / rgammaBayes(tau_epsilon + (double)p*J/2, tau_epsilon*epsilon0 + temp_ss/2);  \n    \n  }\n  \n  output.mu_0 = mu_0new;\n  output.mu = mu.t();\n  output.Sigma = Sigma;\n  output.Omega = Omega;\n  output.epsilon = epsilon_new;\n  return output;    \n           \n\n};\n\n\n\n\n\ndouble MCMC::UpdateK0(  arma::cube Omega, \n                        arma::mat mu_0,\n                        arma::vec m_1  )\n{\n  double tau_2_tot = tau_k0(1);\n  double tau_1_tot = tau_k0(0) + p*K;\n  for(int k=0; k < K; k++)\n      tau_2_tot += as_scalar( (mu_0.col(k) - m_1).t() * Omega.slice(k) * (mu_0.col(k) - m_1));  \n\n  return rgammaBayes(tau_1_tot/2, tau_2_tot/2);\n};\n\n\n\n\n\n\narma::mat MCMC::UpdateSigma1(arma::cube Omega)\n{\n  mat psi_2_tot = Psi_2;\n  for(int k=0; k< K; k++)\n      psi_2_tot += Omega.slice(k);\n\n  return( rWishartArma(inv_sympd(psi_2_tot), K*nu_1 + nu_2) );\n  \n};\n\n\narma::vec MCMC::UpdateM1(   double k_0, \n                            arma::mat mu_0, \n                            arma::cube Omega )\n{\n  mat precision = inv_S_2;\n  vec meanM = inv_S_2*m_2;\n  for(int k=0; k< K; k++)\n  {\n      precision += k_0*Omega.slice(k);\n      meanM += k_0 * ( Omega.slice(k)*mu_0.col(k) );\n  }\n  mat variance = inv_sympd(precision);\n  mat output = mvrnormArma(1, variance*meanM, variance);\n  return( output.row(0).t() );\n};\n\n\n\ndouble MCMC::UpdateEpsilon0(  double epsilon0, \n                              arma::vec epsilon, \n                              double tau_epsilon, \n                              arma::vec tau_epsilon0,\n                              double epsilon0_par  )                                      \n{\n  double output = epsilon0;\n  // proposal \n  double e0_new = as<double>(rbeta(1, epsilon0 * epsilon0_par, epsilon0_par * (1 - epsilon0) ));\n  \n  double log_acc = R::dbeta(e0_new, tau_epsilon0(0), tau_epsilon0(1), 1 );\n  log_acc -= R::dbeta(epsilon0, tau_epsilon0(0), tau_epsilon0(1), 1 );    \n  log_acc -= R::dbeta(e0_new, epsilon0 * epsilon0_par, epsilon0_par * (1 - epsilon0), 1 );\n  log_acc += R::dbeta(epsilon0, e0_new * epsilon0_par, epsilon0_par * (1 - e0_new), 1 );\n  \n  for(int k=0; k<K; k++)\n   log_acc += dInvGamma(epsilon(k), tau_epsilon, tau_epsilon*e0_new) - \n    dInvGamma(epsilon(k), tau_epsilon, tau_epsilon*epsilon0);\n    \n  if( exp(log_acc) > R::runif(0,1) )\n    output = e0_new;\n    \n  return output;  \n}\n\n\n\n\n\n\nRcpp::List MCMC::get_chain()\n{\n  return Rcpp::List::create(  \n    Rcpp::Named( \"alpha\" ) = saveAlpha,\n    Rcpp::Named( \"epsilon0\" ) = saveEpsilon0,\n    Rcpp::Named( \"epsilon\" ) = saveEpsilon,\n    Rcpp::Named( \"k_0\" ) = saveK0,\n    Rcpp::Named( \"m_1\" ) = saveM1,\n    Rcpp::Named( \"mus\" ) = saveMu,\n    Rcpp::Named( \"mu_0\" ) = saveMu0,\n    Rcpp::Named( \"Omega_1\" ) = saveOmega1,\n    Rcpp::Named( \"Omegas\" ) = saveOmega,\n    Rcpp::Named( \"Z\" ) = saveZ,\n    Rcpp::Named( \"w\" ) = saveW,\n    Rcpp::Named( \"logOdds\" ) = saveOdds\n    );\n};\n\n\n\nkernel_coeffs_type MCMC::PriorMuSigmaEpsilon(   arma::mat Sigma_1, \n                                                arma::mat Omega_1, \n                                                double k_0, \n                                                double epsilon0,\n                                                arma::vec m_1 ) \n{ \n  kernel_coeffs_type output;\n  mat Omega(p,p);\n  mat Sigma(p,p);\n  mat mu(p,J);\n  mat mu_0new(p,1);  \n  double epsilon;\n\n  Omega = rWishartArma(Omega_1, nu_1);\n  Sigma = inv_sympd( Omega );   \n  epsilon = 1 / rgammaBayes(tau_epsilon, tau_epsilon*epsilon0);\n  \n  mu_0new = trans(mvrnormArma(1, m_1, Sigma/k_0));    \n  for(int j=0; j<J; j++)\n    mu.col(j) = trans( mvrnormArma(1, mu_0new,  Sigma*epsilon ));      \n  \n  output.mu_0 = mu_0new;\n  output.mu = mu.t();\n  output.Sigma = Sigma;\n  output.Omega = Omega;\n  output.epsilon = epsilon;\n  return output;    \n};\n\n",
    "created" : 1430404534188.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "439|1|462|0|\n",
    "hash" : "3118200166",
    "id" : "A7165A62",
    "lastKnownWriteTime" : 1430597065,
    "path" : "~/Dropbox/Duke/Thesis/locally_tied_stick_breaking/code/V7/MPK/MPK/src/gibbs.cpp",
    "project_path" : "src/gibbs.cpp",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "cpp"
}